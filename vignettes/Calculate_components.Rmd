---
title: "Internship report"
subtitle: "Calculating new data components"
author: "Ludovic Moisan"
supervisors: "Pierre aumond, Paul Chapron, Nicolas Roelandt"
date: "`r Sys.Date()`"
output: 
  html_document :
    theme: united
editor_options: 
  chunk_output_type: console
---

```{r countries-timezones, include = FALSE, cache = TRUE}
query <- "SELECT admin, iso_a2_eh, geog FROM countries;"

countries <- sf::st_read(con,query = query)
countries$iso_a2_eh[countries$iso_a2_eh=="-99"] <- NA

sf_use_s2(FALSE)

clean_track_info <- st_join(clean_track_info, countries, largest = FALSE)

st_crs(clean_track_info) <- 4326

query <- "SELECT fid as timezone_id, geom, utc_format, tz_name1st FROM timezones;"

timezones <- sf::st_read(con,query = query)
#timezones_clean <- timezones[!(is.na(timezones$tz_name1st) | timezones$tz_name1st==""), ] #Dropping rows with NA values to prevent future mistakes

```

```{r intersect geo timezones, include = FALSE, cache = TRUE}

st_crs(clean_track_info) #to check norm id <- 4326 (world default)

st_crs(timezones) <- 4326 #specify world ref to match previous one since NA
st_transform(timezones, crs = 4326)

sf_use_s2(FALSE) #disable spherical geometry use

full_info <- sf::st_join(clean_track_info, timezones) #intersect tracks geog with timezones geom
full_info

#saveRDS(full_info, here("data","full_info.rds"))

```

```{r tag-info, include= FALSE}
query <- "SELECT tv.pk_track, tag_name FROM tracks_view as tv
INNER JOIN noisecapture_track_tag ntt ON tv.pk_track = ntt.pk_track /* Add track tags*/
INNER JOIN noisecapture_tag ntag ON ntag.pk_tag = ntt.pk_tag /* Add track tags*/;"

tag_info <- RPostgreSQL::dbGetQuery(con,statement = query) %>% dplyr::filter(pk_track %in% clean_track_info$pk_track)
(tag_info)

```

```{r time-processing-hour-season, include = FALSE}
all_info <- tag_info %>% 
  dplyr::inner_join(
    full_info %>% filter(!is.na(tz_name1st)) %>% sf::st_drop_geometry()) %>%
  # add local date
  dplyr::mutate(local_time = (lubridate::local_time(lubridate::ymd_hms(record_utc, tz = "UTC"),tz_name1st,   units="hours"))) # target timezone

all_info <- all_info %>% mutate(local_date = case_when(
  ymd(substr(ymd_hms(record_utc) + hm(utc_format),1,10)) == ymd(substr(record_utc,1,10)) ~ ymd_hms((paste(substr(record_utc,1,10),"00:00:00"))) + local_time,
  ymd(substr(ymd_hms(record_utc) + hm(utc_format),1,10)) < ymd(substr(record_utc,1,10)) ~ ymd_hms((paste(substr(record_utc,1,10),"00:00:00"))) - 86400 + local_time,
    ymd(substr(ymd_hms(record_utc) + hm(utc_format),1,10)) > ymd(substr(record_utc,1,10)) ~ ymd_hms((paste(substr(record_utc,1,10),"00:00:00"))) + 86400 + local_time
))

all_info$lon <- as.numeric(all_info$lon)
all_info$lat <- as.numeric(all_info$lat)

#>Les saisons doivent être calculées selon la date ET la latitude.
#>Le calcul de la librairie hydroTSM ne fonctionne que pour la france métropolitaine ou la polynésie française (à spécifier dans "type=")
#>Les dates des débuts de saisons ci-dessous sont génériques, la précision de la date à l'heure près n'est pas nécessaire ici.
#>Les saisons ne sont présentes qu'entres les latitudes (-)23.5 et (-)66.5.
#>L'équateur et les pôles, ne possédant pas vraiment des saisons, sont notées à part, dans la colonne "season" et "hemisphere"

y_m <- format(all_info$record_utc, format ="%m-%d")
all_info$ym <- y_m

north_spring <- "03-21"
north_summer <- "06-22"
north_autumn <- "09-22"
north_winter <- "12-22"
start_year <- "01-01"
end_year <- "12-31"
south_autumn <- "03-21"
south_winter <- "06-22"
south_spring <- "09-22"
south_summer <- "12-22"

all_info <- all_info %>%
  mutate(season = case_when(
    lat > 23.5 & lat < 66.5 & y_m >= north_spring & y_m < north_summer  ~ "spring",
    lat > 23.5 & lat < 66.5 & y_m >= north_summer & y_m < north_autumn  ~ "summer",
    lat > 23.5 & lat < 66.5 & y_m >= north_autumn & y_m < north_winter  ~ "autumn",
    lat > 23.5 & lat < 66.5 & y_m >= north_winter & y_m <= end_year  ~ "winter",
        lat > 23.5 & lat < 66.5 & y_m >= start_year & y_m < north_spring  ~ "winter",

    lat < -23.5 & lat > -66.5 & y_m >= south_autumn & y_m < south_winter  ~ "autumn",
    lat < -23.5 & lat > -66.5 & y_m >= south_winter & y_m < south_spring  ~ "winter",
    lat < -23.5 & lat > -66.5 & y_m >= south_spring & y_m < south_summer  ~ "spring",
    lat < -23.5 & lat > -66.5 & y_m >= south_summer & y_m <= end_year  ~ "summer",
        lat < -23.5 & lat > -66.5 & y_m >= start_year & y_m < south_autumn  ~ "summer",
    
    lat <= 23.5 & lat >= -23.5 ~ "equator",
    lat >= 66.5 | lat <= -66.5 ~ "pole"
    ))

all_info <- all_info %>%
  mutate(hemisphere = case_when(
    lat > 23.5 & lat < 66.5 ~ "north",
    lat < -23.5 & lat > -66.5 ~ "south",
    lat <= 23.5 & lat >= -23.5 ~ "equator",
    lat >= 66.5 | lat <= -66.5 ~ "pole"
  ))

#>La France possède de nombreux territoires d'outre mer qui sont considérés dans nos données sous le même nom "France"
#>Le territoire est renommé "France_dromcom" si sa position ne fait pas partie d'une bounding box lat(40;55) lon(-6;10) 
#>(approximation large autour de la France)
#>Ce processus pourrait être remplacé par une meilleure définition des pays dès le départ, mais je n'ai pas eu le  temps de proposer une nouvelle création de tables de données POSTGRE pertinentes pour le projet


#MODIFIER avec france metro
all_info <- all_info %>% 
  mutate(admin = case_when(
    admin == "France" & ((lat < 40 | lat > 55) & (lon < -6 | lon > 10)) ~ "Dromcom",
    TRUE ~ admin
  ))

all_info <- all_info %>% mutate(week_end = case_when(
  chron::is.weekend(local_date) ~ TRUE,
  TRUE ~ FALSE
))

#saveRDS(all_info, here("data","all_info.rds"))
```

```{r compute-sunrise, include = FALSE, cache= TRUE}
get_sunrise <- function(pk_track, date, lat, lon, tz= "UTC") {
  # compute sunrise time from localisation and UTC time
  #return NA if error
  in_pk_track = pk_track
  in_lat = round(lat,5)
  in_lon = round(lon,5)
  in_tz = tz
  
  sunrise = tryCatch(suncalc::getSunlightTimes(
    date = lubridate::date(date),
    lat = in_lat,
    lon = in_lon,
    tz   = in_tz
  )$sunrise, error=function(e) NA)

  return(dplyr::tribble(
 ~pk_track, ~sunrise_utc,
 in_pk_track, sunrise)
)
}

get_sunset <- function(pk_track, date, lat, lon, tz= "UTC") {
  # compute sunset time from localisation and UTC time
  #return NA if error
  in_pk_track = pk_track
  in_lat = round(lat,5)
  in_lon = round(lon,5)
  in_tz = tz
  
  sunset = tryCatch(suncalc::getSunlightTimes(
    date = lubridate::date(date),
    lat = in_lat,
    lon = in_lon,
    tz   = in_tz
  )$sunset, error=function(e) NA)

  return(dplyr::tribble(
 ~pk_track, ~sunset_utc,
 in_pk_track, sunset)
)
}


# Compute sunrise hours for each track in a new dataframe
# Impossible de calculer directement pour la timezone définie avec la local_date, le package suncalc ayant un bug
# Plus de détail : https://github.com/datastorm-open/suncalc/issues/2

sunrises <- purrr::pmap_dfr(all_info[!duplicated(all_info$pk_track),] %>% select(pk_track, date = record_utc, lat, lon), get_sunrise)
sunsets <- purrr::pmap_dfr(all_info[!duplicated(all_info$pk_track),] %>% select(pk_track, date = record_utc, lat, lon), get_sunset)

sunrises <- inner_join(sunrises %>% dplyr::filter(!is.na(sunrise_utc)),
            all_info %>% dplyr::select(pk_track, tag_name, tz_name1st),
            by = "pk_track") %>% dplyr::mutate(local_sunrise = lubridate::local_time(sunrise_utc,tz_name1st, units = "hours"))
sunsets <- inner_join(sunsets %>% dplyr::filter(!is.na(sunset_utc)),
            all_info %>% dplyr::select(pk_track, tag_name, tz_name1st),
            by = "pk_track") %>% dplyr::mutate(local_sunset = lubridate::local_time(sunset_utc,tz_name1st, units = "hours"))

sun_info <- inner_join(sunrises,sunsets)

#saveRDS(sun_info, here("data","sun_info.rds"))
```

```{r time-after-sunrise, include = FALSE}
# join sunrises to study data

all_info_sun <- left_join(all_info,sun_info)

# Mutating hours to fit in a 12h window around the sunrise or sunset
all_info_sun <- 
  all_info_sun %>% mutate(after_sunrise = case_when(
  local_time - local_sunrise >= 12 ~ -(24 - local_time + local_sunrise),
  TRUE ~ local_time - local_sunrise))

all_info_sun <- 
  all_info_sun %>% mutate(after_sunset = case_when(
  local_time - local_sunset > 12 ~ -(24 - local_time - local_sunset),
  local_time - local_sunset < -12 ~ 24 - abs(local_time - local_sunset),
  TRUE ~ local_time - local_sunset
))


#saveRDS(all_info_sun, file = "vignettes/all_info_sun.rds")
```